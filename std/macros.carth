(defmacro apps ()
  (case (op x) x)
  (case (op x1 x2 xs ...) (apps op (op x1 x2) xs ...)))

(defmacro appsr ()
  (case (op x) x)
  (case (op x xs ...) (op x (appsr op xs ...))))

(defmacro list ()
  (case (xs ...) (appsr list/cons xs ... Nil)))

(defmacro +s () (case (xs ...) (apps + xs ...)))
(defmacro =s ()
  (case (x xs ...) (all (= x) (list/iter (list xs ...)))))

(defmacro io/wrap ()
  (case (computation) (IO (fun (real-world) [computation real-world]))))

(defmacro lazy ()
  (case (computation) (Lazy [(unsafe-perform-io mutex/new)
                             (box (Left (fun (Unit) computation)))])))

(defmacro nonstrict ()
  (case (computation) (fun (Unit) computation)))

;; TODO: Fix macro case lhs name to be unique and not collide with user names. Example
;;       when `do-a` was called `a`:
;;
;;       (do maybe/bind
;;           (<- [inp a] (pa inp))
;;           (<- [inp _b] (pb inp))
;;           (Some [inp a]))
;;
;;       The type error was hard to parse, but I think that the `a` in the last line is
;;       what caused it. Resulted in some strange macro expansion.
(defmacro do (<-)
  (case (do-bind do-ma) do-ma)
  (case (do-bind (<- do-a do-ma) do-mbs ...)
        (do-bind (fun (do-a) (do do-bind do-mbs ...)) do-ma))
  (case (do-bind (let1 do-x do-a) do-mbs ...)
        (let1 do-x do-a (do do-bind do-mbs ...)))
  (case (do-bind (let do-bs) do-mbs ...)
        (let do-bs (do do-bind do-mbs ...)))
  (case (do-bind do-ma do-mbs ...)
        (do-bind (fun (_) (do do-bind do-mbs ...)) do-ma)))
