(import macros)
(import iter)
(import list)
(import maybe)
(import either)
(import math)
(import lazy)
(import mem)
(import array)
(import string)
(import queue)
(import io)
(import net)
(import parse)
(import map)
(import set)
(import priority-queue)

(define (cons x xs) [x . xs])
(define (cons' x y) [x y])

(define (car      [x . _])           x)
(define (cadr     [_ x . _])         x)
(define (caddr    [_ _ x . _])       x)
(define (cadddr   [_ _ _ x . _])     x)
(define (caddddr  [_ _ _ _ x . _])   x)

(define (cdr      [_ . x])           x)
(define (cddr     [_ _ . x])         x)
(define (cdddr    [_ _ _ . x])       x)
(define (cddddr   [_ _ _ _ . x])     x)
(define (cdddddr  [_ _ _ _ _ . x])   x)

(define (map-car     f [a . b]) [(f a) . b])
(define (map-cadr    f [a . b]) [a . (map-car f b)])
(define (map-caddr   f [a . b]) [a . (map-cadr f b)])
(define (map-cadddr  f [a . b]) [a . (map-caddr f b)])
(define (map-caddddr f [a . b]) [a . (map-cadddr f b)])

(define (map-cdr     f [a . b]) [a . (f b)])
(define (map-cddr    f [a . b]) [a . (map-cdr f b)])
(define (map-cdddr   f [a . b]) [a . (map-cddr f b)])
(define (map-cddddr  f [a . b]) [a . (map-cdddr f b)])
(define (map-cdddddr f [a . b]) [a . (map-cddddr f b)])

(define (map-cons f g [a . b]) [(f a) . (g b)])

(define (map-two f g [a b]) [(f a) (g b)])
(define (map-three f g h [a b c]) [(f a) (g b) (h c)])

(define (map-both f [a1 a2]) [(f a1) (f a2)])

(define (show-two show-a show-b [a b]) (apps str-append "[" (show-a a) " " (show-b b) "]"))
(define (show-three show-a show-b show-c [a b c])
  (apps str-append "[" (show-a a) " " (show-b b) " " (show-c c) "]"))

(define (swap [a b]) [b a])

(define: (undefined x)
    (forall (a) (Fun Unit a))
  (panic "undefined"))

(extern -panic (Fun Str Unit))
(define (panic msg)
  (seq (-panic msg) (undefined Unit)))

(data Cmp
  Lt Eq Gt)

(define (num/cmp a b)
  (if (< a b) Lt
    (if (= a b) Eq
      Gt)))

(define (cmp/< cmp a b)
  (match (cmp a b)
    (case Lt True)
    (case _  False)))

(define (cmp/= cmp a b)
  (match (cmp a b)
    (case Eq True)
    (case _  False)))

(define (cmp/min cmp a b)
  (match (cmp a b)
    (case Gt b)
    (case _ a)))

(define (cmp/max cmp a b)
  (match (cmp a b)
    (case Lt b)
    (case _ a)))

(define (cmp-two cmp-a cmp-b [a1 b1] [a2 b2])
  (match (cmp-a a1 a2)
    (case Eq (cmp-b b1 b2))
    (case c c)))
(define (cmp-three cmp-a cmp-b cmp-c [a1 . rest1] [a2 . rest2])
  (match (cmp-a a1 a2)
    (case Eq (cmp-two cmp-b cmp-c rest1 rest2))
    (case c c)))
(define (cmp-four cmp-a cmp-b cmp-c cmp-d [a1 . rest1] [a2 . rest2])
  (match (cmp-a a1 a2)
    (case Eq (cmp-three cmp-b cmp-c cmp-d rest1 rest2))
    (case c c)))
(define (cmp-five cmp-a cmp-b cmp-c cmp-d cmp-e [a1 . rest1] [a2 . rest2])
  (match (cmp-a a1 a2)
    (case Eq (cmp-four cmp-b cmp-c cmp-d cmp-e rest1 rest2))
    (case c c)))

;;; Strings

(extern show-int (Fun Int Str))
(extern show-nat (Fun Nat Str))
(extern show-f64 (Fun F64 Str))

(define show-bool (fmatch (case True "True") (case False "False")))

(extern str-append (Fun Str Str Str))

;;; Function

(define (uncurry f [a b]) (f a b))
(define (curry f a b) (f [a b]))

(define (app f a) (f a))
(define (rapp a f) (f a))

(define (const a b) a)
(define (seq   a b) b)

(define (<o f g a) (f (g a)))
(define (<oo f g a b) (f (g a b)))
(define (<ooo f g a b c) (f (g a b c)))
(define (o> f g a) (g (f a)))
(define (oo> f g a b) (g (f a b)))
(define (ooo> f g a b c) (g (f a b c)))

(define (<| f a) (f a))
(define (|> a f) (f a))

(define (flip f a b) (f b a))

(define (id x) x)

(data Void)

(define: void-elim
    (forall (a) (Fun Void a))
  (fmatch))

(define (to-nat x) (: (cast x) Nat))
(define (to-int x) (: (cast x) Int))
(define (to-n16 x) (: (cast x) Nat16))
(define (to-n8 x) (: (cast x) Nat8))
