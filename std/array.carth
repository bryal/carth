(import iter)
(import mem)

(define (array/length (Array _ n)) n)

(define: (array/iter (Array ptr len))
    (forall (a) (Fun (Array a) (Iter a)))
  (map (<o deref (<o (ptr/+ ptr) cast))
       (xrange 0 (cast len))))

(define: (array/iter-rev (Array ptr len))
    (forall (a) (Fun (Array a) (Iter a)))
  (map (fun (i) (deref (ptr/+ ptr (- len (cast i)))))
       (xrange 1 (+ 1 (cast len)))))

(define array/nil (Array mem/unsafe-null (cast 0)))

(define (array/nil? a) (= (cast 0) (array/length a)))

(define: (array/unsafe-uninit n) (forall (a) (Fun Nat (Array a)))
  (Array (cast-ptr (id@"GC_malloc" (* (sizeof a) n)))
         n))

(define (array/singleton x)
  (Array (box x) (cast 1)))

;; TODO: This is inefficient. Do something similar to Rust's Vec instead. Start array at
;; reserved size 1, and everytime space is full, increase the reserved size
;; exponentially. At the end, do a final reallocation to shrink to the now known size.
(define: (array/collect xs) (forall (a) (Fun (Iter a) (Array a)))
  (array/collect-list (list/collect xs)))

(define (array/collect-list xs)
  (foldl (fun (v [i x]) (array/mutate i x v))
         (array/unsafe-uninit (list/count xs))
         (enumerate (list/iter xs))))

(define: (array/mutate i x (Array ptr n))
    (forall (a) (Fun Nat a (Array a) (Array a)))
  (if (>= i n)
      (panic "array/mutate after end of array")
    (seq (store x (ptr/+ ptr i))
         (Array ptr n))))

(define (array/clone (Array p n))
  (let1 (Array p' _) (array/unsafe-uninit n)
    (seq (memcpy' p' p n)
         (Array p' n))))

(define (array/set! i x arr)
  (array/mutate i x (array/clone arr)))

(define (array/modify! f i a)
  (array/set! i (f (array/lookup! i a)) a))

(extern memcpy (Fun (Box Nat8) (Box Nat8) Nat (Box Nat8)))

(define: (memcpy' dest src count)
    (forall (a) (Fun (Box a) (Box a) Nat (Box a)))
  (transmute (memcpy (transmute dest)
                     (transmute src)
                     (* count (sizeof a)))))

(define: (array/append (Array px nx) (Array py ny))
    (forall (a) (Fun (Array a) (Array a) (Array a)))
  (let1 (Array pz nz) (array/unsafe-uninit (nat/nowrap+ nx ny))
    (apps seq
          (memcpy' pz px nx)
          (memcpy' (ptr/+ pz nx) py ny)
          (Array pz nz))))

(define (array/lookup i a)
  (if (< i (array/length a))
      (Some (array/unsafe-lookup-unchecked i a))
    None))

(define array/lookup! (<oo unwrap! array/lookup))

(define (array/unsafe-lookup-unchecked i (Array ptr _))
  (deref (ptr/+ ptr i)))

;;? Returns index of the first occurence of the element in the array, if it *is* an element
(define (array/find x xs)
  (array/find-by (= x) xs))

(define (array/find-end x xs)
  (array/find-by-end (= x) xs))

;;? Returns the index of the first element that satisfies the predicate
(define (array/find-by p xs)
  (let1 i (count (take-while (<o not p) (array/iter xs)))
    (if (< i (array/length xs))
        (Some i)
      None)))

(define (array/find-by-end p xs)
  (let1 i (count (take-while (<o not p) (array/iter-rev xs)))
    (if (< i (array/length xs))
        (Some (- (array/length xs) i))
      None)))

(define: (array/find-slice-by f xs)
    (forall (a b) (Fun (Fun (Array a) (Maybe b)) (Array a) (Maybe [Nat b])))
  (iter/first (filter-map (fun ([i ys]) (maybe/map (cons' i) (f ys)))
                          (enumerate (array/suffixes xs)))))

(define: (array/find-slice-by' f xs)
    (forall (a) (Fun (Fun (Array a) Bool) (Array a) (Maybe Nat)))
  (iter/first (filter-map (fun ([i ys]) (if (f ys) (Some i) None))
                          (enumerate (array/suffixes xs)))))

(define (array/suffixes xs)
  (if (array/nil? xs)
      iter/nil
    (iter/cons xs (map (fun (i) (array/from i xs)) (xrange 1 (cast (array/length xs)))))))

;;? Supports negative `m` for python like range indexing
(define: (array/from i (Array ptr len))
    (forall (a) (Fun Int (Array a) (Array a)))
  (let1 i (if (< i 0)
              (cast (max 0 (+ (cast len) i)))
            (min len (cast i)))
    (Array (ptr/+ ptr i) (- len i))))

;;? Supports negative `m` for python-like range indexing
(define: (array/to i (Array ptr len))
    (forall (a) (Fun Int (Array a) (Array a)))
  (let1 i (if (< i 0)
              (cast (max 0 (+ (cast len) i)))
            (min len (cast i)))
    (Array ptr i)))

(define (array/slice i j xs)
  (let ((len (array/length xs))
        (i (if (< i 0)
               (cast (max 0 (+ (cast len) i)))
             (min len (cast i)))))
    (array/from (cast i) (array/to j xs))))

;;? Binary search
;;?
;;? If there are multiple matches, the index of any of them may be returned.
(define: (array/search cmp-x ys)
    (forall (a) (Fun (Fun a Cmp) (Array a) (Either Nat Nat)))
  (define (go start end)
    (if (= start end)
        (Left start)
      (let ((i (+ start (/ (- end start) (cast 2))))
            (y (array/lookup! i ys)))
        (match (cmp-x y)
          (case Eq (Right i))
          (case Lt (go start i))
          (case Gt (go (inc i) end))))))
  (go (cast 0) (array/length ys)))

;; (define main
;;   (display (either/show show-nat show-nat (array/search int/cmp 3 (array/collect (skip-every-nth 1 (xrange 0 10)))))))

(define (array/split i (Array ptr n))
  (if (<= i n)
      (Some [(Array ptr i) (Array (ptr/+ ptr i) (- n i))])
    None))

(define (array/take-split i a)
  (match (array/split i a)
    (case (Some p) p)
    (case None [a array/nil])))

(define (array/split-first (Array ptr n))
  (if (= n (cast 0))
      None
    (Some [(deref ptr) (Array (ptr/+ ptr (cast 1)) (- n (cast 1)))])))

(define (array/split-last (Array ptr n))
  (if (= n (cast 0))
      None
    (Some [(Array ptr (- n (cast 1))) (deref (ptr/+ ptr (- n (cast 1))))])))

(define (array/= xs ys)
  (if (= (array/length xs) (array/length ys))
      (all (fun ([x y]) (= x y)) (zip (array/iter xs) (array/iter ys)))
    False))

(define (array/show show-elem a)
  (apps str-append "{" (string/concat (intersperse " " (map show-elem (array/iter a)))) "}"))

(define (array/build f acc n)
  (foldl (fun ([acc a] i) (let1 [acc' x] (f acc i)
                            [acc' (array/mutate i x a)]) )
         [acc (array/unsafe-uninit n)]
         (map to-nat (xrange 0 (to-int n)))))

(define: (merge-sort cmp xs)
    (forall (a) (Fun (Fun a a Cmp) (Array a) (Array a)))
  (define (merge a i [y ys] zs)
    (match (next zs)
      (case (Some [z zs'])
            (match (cmp y z)
              (case Lt (merge (array/mutate i y a) (+ i (to-nat 1)) [z zs'] ys))
              (case _  (merge (array/mutate i z a) (+ i (to-nat 1)) [y ys] zs'))))
      (case None
            (foldl (fun (a [k y]) (array/mutate (+ i k) y a))
                   a
                   (enumerate (iter/cons y ys))))))
  (if (<= (array/length xs) (to-nat 1))
      xs
    (let1 [ys zs] (unwrap! (array/split (/ (array/length xs) (to-nat 2)) xs))
      (merge (array/unsafe-uninit (array/length xs))
             (to-nat 0)
             (next! (array/iter (merge-sort cmp ys)))
             (array/iter (merge-sort cmp zs))))))

(define (array/first! a)
  (array/lookup! (to-nat 0) a))

(define (array/last! a)
  (let1 n (array/length a)
    (if (= n (to-nat 0))
        (panic "array/last! of empty array")
      (array/lookup! (- n (to-nat 1)) a))))

(define: (array/concat as) (forall (a) (Fun (List (Array a)) (Array a)))
  (let1 len (sum (map array/length (list/iter as)))
    (cadr (foldl (fun ([i (Array pacc nacc)] (Array p n))
                   (seq (memcpy' (ptr/+ pacc i) p n)
                        [(+ i n) (Array pacc nacc)]))
                 [(to-nat 0) (array/unsafe-uninit len)]
                 (list/iter as)))))

(define: (array/insert-grow! i x xs) (forall (a) (Fun Nat a (Array a) (Array a)))
  (let1 [ys zs] (unwrap! (array/split i xs))
    (array/concat (list ys (array/singleton x) zs))))

(define: (array/insert-displace-left! i x xs) (forall (a) (Fun Nat a (Array a) [a (Array a)]))
  (let (([ys zs] (unwrap! (array/split (+ i (to-nat 1)) xs)))
        ([y ys] (unwrap! (array/split-first ys))))
    [y (array/concat (list ys (array/singleton x) zs))]))

(define: (array/insert-displace! i x xs) (forall (a) (Fun Nat a (Array a) [(Array a) a]))
  (let (([ys zs] (unwrap! (array/split i xs)))
        ([zs z] (unwrap! (array/split-last zs))))
    [(array/concat (list ys (array/singleton x) zs)) z]))
