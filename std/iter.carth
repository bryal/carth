(import std)
(import list)
(import maybe)

(data (Iter a)
  (Iter (Fun Unit (Maybe (Pair a (Iter a))))))

(define iter/nil
  (Iter (fun (_) None)))

(define (iter/once x)
  (iter/cons x iter/nil))

(define (iter/cons x xs)
  (Iter (fun (_) (Some (Pair x xs)))))

(define (iter/chain xs ys)
  (Iter (fun (_) (maybe (next ys)
                        (fun ((Pair x xs'))
                          (Some (Pair x (iter/chain xs' ys))))
                        (next xs)))))

(define (next (Iter it)) (it Unit))
(define next! (<o unwrap! next))

(define: (xrange a b) (Fun Int Int (Iter Int))
  (take (- b a)       (range-from a)))
(define: (range  a b) (Fun Int Int (Iter Int))
  (take (inc (- b a)) (range-from a)))

(define (range-from a)
  (Iter (fun (_) (Some (Pair a (range-from (inc a)))))))

(define (take n xs)
  (Iter (if (> n 0)
            (fun (_) (map-maybe (map-cdr (take (- n 1))) (next xs)))
          (fun (_) None))))

(define: (skip n xs)
    (forall (a) (Fun Nat (Iter a) (Iter a)))
  (if (= n (cast 0))
      xs
    (match (next xs)
      (case None iter/nil)
      (case (Some (Pair _ xs)) (skip (dec n) xs)))))

(define (skip-while pred xs)
  (letrec ((skip-while' (fun (xs)
                          (match (next xs)
                            (case (Some (Pair x xs'))
                                  (if (pred x)
                                      (skip-while' xs')
                                    (Some (Pair x xs'))))
                            (case None None)))))
    (Iter (fun (_) (skip-while' xs)))))

(define (for xs f) (foldl (const f) Unit xs))

(define (map f xs)
  (Iter (fun (_) (map-maybe (map-both f (map f)) (next xs)))))

(define (filter pred xs)
  (Iter (fun (_) (map-maybe (map-cdr (filter pred))
                            (next (skip-while (<o not pred) xs))))))

(define: (foldl f acc xs)
    (forall (acc x) (Fun (Fun acc x acc) acc (Iter x) acc))
  (define (foldl' (Pair acc xs))
    (match (next xs)
      (case (Some (Pair x xs'))
            (foldl' (Pair (f acc x) xs')))
      (case None
            acc)))
  (foldl' (Pair acc xs)))

(define (reverse xs)
  (define (rev xs a)
    (maybe a (fun ((Pair x xs')) (rev xs' (iter/cons x a))) (next xs)))
  (rev xs iter/nil))

(define (iter/length xs)
  (foldl (<o const inc) 0 xs))

(define enumerate (zip (range-from (: (cast 0) Nat))))

(define (zip xs ys)
  (Iter (fun (_) (maybe/map2 (fun ((Pair x xs') (Pair y ys'))
                               (Pair (Pair x y) (zip xs' ys')))
                             (next xs) (next ys)))))
